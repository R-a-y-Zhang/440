from math import sqrt

class node:
    # g = travel cost from start, h = heuristic cost
    def __init__(self, c, h, g, p):
        self.c = c
        self.h = h
        self.g = g
        self.p = p
    def equals(n):
        if self.c == n.c and self.h == c.h and self.g == c.g and self.p == c.p:
            return True
        return False

def in_bounds(array, c, bh, bw, v):
    if array[c[0]][c[1]] == v:
        return False
    if c[0] < 0 or c[0] >= bh or c[1] < 0 or c[1] >= bw:
        return False
    return True

def sum_tuple(t1, t2):
    return (t1[0]+t2[0], t1[1]+t2[1])

def manhattan(c1, c2):
    return abs(c1[0] - c2[0]) + abs(c1[1] + c2[1])

def calculate_travel(c1, c2, c1v, c2v):
    deltaH = c1[0] - c2[0]
    deltaW = c1[1] - c2[1]
    if (deltaH == 0 || deltaW == 0) and deltaH != deltaW: # not diagonal
        if c1v == c2v == 2: # hard to hard
            return 2
        if c1v == c2v == 1: # soft to soft
            return 1
        return 1.5 # mixed
    if deltaH != 0 and deltaW != 0:
        if c1v == c2v == 2:
            return sqrt(8)
        if c1v == c2v == 1:
            return sqrt(2)
        return (sqrt(2) + sqrt(8))/2.0

def find(set_, c):
    for i in range(len(set_)):
        if set_[i].c == c:
            return i

def aStarSolve(array, start, end):
    openSet = []
    opens = []
    closedSet = []
    height = len(array)
    width = len(array[0])
    current = node(start, manhattan(start, end), 0, None)
    openSet.append(current)
    opens.append(cc)
    neighborOffsets = [(1,0), (1,1), (0,1), (-1,0), (-1,1), (-1,-1), (1,-1), (0,-1)]
    while openSet:
        current = reduce(lambda c1, c2: c1 if c1.h+c1.g < c2.h+c2.g else c2, openSet)
        current.remove(current)
        cc = current.c
        opens.remove(cc)
        if current.c is end:
            return True
        neighbors = list(filter(lambda n: in_bounds(array, sum_tuple(current.c, n)),
            height, width, 3), neighborOffsets)
        for n in neighbors: # n, tuple of the coordinates of the neighbor
            if n in closedSet:
                continue
            
            tval = current.g + calculate_travel(cc, n, array[cc[0]][cc[1]], array[n[0]][n[1]])
            if n in opens:
                nnode = openSet[find(openSet, n)] # finds the node in the openSet
                # calculating travel cost from the start to that cell
                if tval < nnode.g: # if travel cost is better, update
                    nnode.g = tval
                    nnode.p = current
            else: # is not in the openSet
                nnode = node(n, manhattan(start, n), tval, current)
                openSet.append(nnode)
                opens.append(n)
