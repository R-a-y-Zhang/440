from math import sqrt

def calculate_manhattan(array, target): # calculating manhattan distance
    th = target[0]
    tw = target[1]
    height = len(array)
    width = len(array[0])
    man_arr = [[0 for x in range(width)] for x in range(height)]
    for i in range(height):
        for j in range(width):
            man_arr[i][j] = abs(th - i) + abs(tw - j)
    return man_arr

# vx is the value of a blocked square, any square with that value or which exceeds it is
# considered inaccessible
def check_if_valid(array, s, b0, b1, vx):
    h = s[0]
    w = s[1]
    if array[h][w] >= vx: # if square is "blocked"
        return False
    if h < b0[0] or h >= b1[0] or w < b0[1] or w >= b1[1]: # if square is out of bounds
        return False
    return True

def sum_lists(t1, t2):
    if len(t1) is not len(t2):
        return None
    v = []
    for i in range(len(t1)):
        v.append(t1[i] + t2[i])
    return tuple(v)

def reconstruct_path():
    return True

def is_hard(array, c):
    print(c[0], c[1])
    if array[c[0]][c[1]] == 1:
        return 0
    if array[c[0]][c[1]] == 2:
        return 1
    if array[c[0]][c[1]] == 3:
        return 2

def reconstruct_path():
    return None

VX = 3
def ASSolve(array, c1, c2):
    # initial setup
    height = len(array)
    width = len(array[0])
    h = calculate_manhattan(array, c2) # the heuristic
    neighborOffsets = [(1,0), (-1,0), (0,1), (0,-1), (1,1), (-1,1), (1,-1), (-1,-1)]
    # calculation start
    openSet = [(0, c1)]
    closedSet = []
    hscores = {}
    subpaths = {}
    while len(openSet):
        cg = min(openSet)
        current = cg[1]
        cval = cg[0]
        c_hard = is_hard(array, current)
        openSet.remove(current)
        neighbors = filter(lambda n: array[n[0]][n[1]] != VX,
                [sum_lists(current, n) for n in neighborOffsets])
        for n in neighbors:
            if n is c2: # found destination
                return True
            # calculating travel cost
            deltah = current[0] - n[0]
            deltaw = current[1] - n[1]
            hard = is_hard(array, n)
            tval = 0
            if c_hard == hard == 1: # all hard
                if deltah is not 0 and deltaw is not 0: # diagonal motion
                    tval = sqrt(8)
                else: # vertical or horizontal
                    tval = 2.0
            elif (c_hard < 2 and hard < 2) and c_hard != hard: # hard to not hard
                if deltah is not 0 and deltaw is not 0:
                    tval = (sqrt(2) + sqrt(8)) / 2.0
                else:
                    tval = 1.5
            elif c_hard == hard == 0: # normal
                if deltah is not 0 and deltaw is not 0:
                    tval = sqrt(2)
                else:
                    tval = 1
            hval = h[n[0]][n[1]]
            # deciding if it's a better path
            if n not in closedSet:
                openSet.add((hval, n))
            elif hscores[n] >= hval:
                continue
            subpaths[n] = current
            hscores[n] = hval
    return None
